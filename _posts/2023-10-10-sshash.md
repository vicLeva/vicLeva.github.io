## SSHash : Sparse and skew hashing of K-mers - 2022

[LINK](https://academic.oup.com/bioinformatics/article/38/Supplement_1/i185/6617506) 

### Authors  
Giulio Ermanno Pibiri

### Résumé

#### Préliminaires

Objectif : n kmers dict qui supporte membership queries : "kmer in dict ?"\
réalisation : à chaque kmer est attribué un entier entre 0 et n via perfect hash function (via statistical minimisers properties) 

*Lookup*(g) retourne l'identifiant integer i du kmer g\
*Access*(i) retourne le kmer encodé par i dans le dict  

Minimisers choisis : m-mer avec m < k qui minimise la valeur obtenue après hachage\
(k-m+2)/2 fois moins de minimisers que de kmers

**Elias fano encoding** :
[Link](https://www.antoniomallia.it/sorted-integers-compression-with-elias-fano-encoding.html)\
Représentation unaire/binaire d'une suite d'entiers monotone (only croissante or only décroissante) -> compression

#### SSHash

Dictionnaire construit à partir des paths d'un dBG. Plus précisemment depuis les super-kmers (=maximal sequences of kmer having the same minimisers)

![figure1](/assets/fulgor1.png)

Different objects from figure 1:
  + *Endpoints* : la database est écrite sous forme binaire (2bits/nucl), *Endpoints* est la liste des séparations entre strings de la database. compressed with elias-fano

  + *Sizes* : array de taille |minimisers|+1. A la position f(r)+1 (f = hachage par MPHF du minimiser r <=> bucket identifier de r, en sachant que le bucket de r est le set de tous les super-kmers ayant pour minimiser r), on a la taille du bucket de r, donc le nombre de super-kmers partageant r.\
  *Sizes* est ensuite modifié pour que chaque *Sizes*[i] soit égal à *Sizes*[i] + *Sizes*[i-1], *Sizes*[f(r)]  


#### Résultats




