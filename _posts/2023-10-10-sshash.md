## SSHash : Sparse and skew hashing of K-mers - 2022

[LINK](https://academic.oup.com/bioinformatics/article/38/Supplement_1/i185/6617506) 

### Authors  
Giulio Ermanno Pibiri

### Résumé

#### Préliminaires

Objectif : n kmers dict qui supporte membership queries : "kmer in dict ?"\
réalisation : à chaque kmer est attribué un entier entre 0 et n via perfect hash function (via statistical minimisers properties) 

*Lookup*(g) retourne l'identifiant integer i du kmer g\
*Access*(i) retourne le kmer encodé par i dans le dict  

Minimisers choisis : m-mer avec m < k qui minimise la valeur obtenue après hachage\
(k-m+2)/2 fois moins de minimisers que de kmers

**Elias fano encoding** :
[Link](https://www.antoniomallia.it/sorted-integers-compression-with-elias-fano-encoding.html)\
Représentation unaire/binaire d'une suite d'entiers monotone (only croissante or only décroissante) -> compression

#### SSHash

Dictionnaire construit à partir des paths d'un dBG. Plus précisemment depuis les super-kmers (=maximal sequences of kmer having the same minimisers)

![figure1](/assets/sshash1.png)

Different objects from figure 1:
  + *Endpoints* : la database est écrite sous forme binaire (2bits/nucl), *Endpoints* est la liste des séparations entre strings de la database. compressed with elias-fano

  + *Sizes* : array de taille |minimisers|+1. A la position f(r)+1 (f = hachage par MPHF du minimiser r <=> bucket identifier de r, en sachant que le bucket de r est le set de tous les super-kmers ayant pour minimiser r), on a la taille du bucket de r, donc le nombre de super-kmers partageant r.\
  *Sizes* est ensuite modifié pour que chaque *Sizes*[i] soit égal à *Sizes*[i] + *Sizes*[i-1], *Sizes*[f(r)] contient maintenant le nombre de super-kmers avant le bucket de r (dans l'ordre de f, la MPHF). compressed with elias-fano

  +  *Offsets* : array stockant le starting point de tous les super-kmers dans la database, trié par f (la MPHF). Cela permet que pour un minimiser r étant présent dans plusieurs super-kmers, ces super-kmers ont leur positions stockées consécutivement dans *Offsets*

Fonctionnement Figure 1 :
On cherche le kmer g, son minimiser est haché pour donner son bucket id : 5. Dans *Sizes* à la position 5 on trouve 7, et à la position 4 on trouve 5, ça signifie que 2 (7-5) super-kmers partagent le minimiser de g. On commence donc par le super-kmer n°7 dans *Offsets* puis le n°8. On retrouve bien g dans le superkmer n°8 à la position 255 dans la database, commençant au 8e caractère dans le superkmer.


#### Résultats




