## Fulgor: A Fast and Compact *k*-mer Index for Large-Scale Matching and Color Queries - 2023

[LINK](https://drops.dagstuhl.de/opus/volltexte/2023/18644/) 

### Authors  
Fan, Jason and Singh, Noor Pratap and Khan, Jamshed and Pibiri, Giulio Ermanno and Patro, Rob

### Résumé

#### En 2 lignes

Dict de kmer avec [SSHash]({% https://vicleva.github.io/2023/10/10/sshash.html 2023-10-10-sshash %}), unitigs d'un ccdbg triés par couleur donc fast kmer -> unitig -> color. 

#### Préliminaires

*Color*(x) = ensemble des références dans lesquelles le kmer x apparaît. 1 référence = 1 string dans {A, T, C, G}, un génome par exemple.

L'index serait la structure qui permet de trouver *Color*(x) pour chaque kmer x existant. (avec x plus petit que les références ofc)

Idée de base : **inverted index** + dict pour avoir x -> *Color*(x)\
Un index *L* va contenir *Color*(x) pour chaque kmer de toutes les références disponibles.\
Un dictionnaire *D* va contenir tous les kmers distincts (n en tout). Ce dictionnaire supporte *Lookup*(x), qui retourne false if x not found et sinon un id unique dans {1,...,n}.\
*Lookup*(x) donnera donc normalement l'adresse de *Color*(x) dans l'index, permettant de retrouver le format compressé des références recherchées. 

Usage de **ccdBG** :\
**de Bruijn Graph** : graphe qui possède des kmers en tant que noeuds et une arête entre 2 noeuds si ces 2 kmers (noeuds) partagent k-1 nucléotides.\
**compacted de Bruijn Graph** : dBG où une suite de plusieurs noeuds consécutifs (sans branchement extérieur) est concaténée pour obtenir un unitig (=1 noeud contenant un string + long qu'un simple kmer).\
**colored compacted de Bruijn Graph** : cdBG où chaque noeud accueille en plus l'info de *Color*(x). (un unitig est monochromatique -> tous les kmers le constituant partagent les memes couleurs)

*ColorID*(u) = couleur de l'unitig u

#### L'index de Fulgor

![figure1](/assets/fulgor1.png)
A schematic picture of the index described in Section 3, highlighting the interplay between the k-mer dictionary D, the bit-vector B, and the inverted index L. The red arrows show how the index is queried for a k-mer x, assuming that x occurs in unitig u6 and has color C3. The k-mer x is first mapped by D to its unitig u6 via the query *UnitigID*(x) = 6. Then we compute *ColorID*(u6) = *Rank1*(6, B) + 1 = 2 + 1 = 3 and lastly retrieve C3 from L

Dans les faits :
  + 1 ccdBG
  + 1 dict kmer -> unitig via [SSHash]({% https://vicleva.github.io/2023/10/10/sshash.html 2023-10-10-sshash %})

  + 1 dict unitig -> color. Ici grâce à SSHash, les unitigs peuvent être permutés comme on veut sans impacter les perfs. Les unitigs sont donc triés par couleur, ils sont successifs dans SSHash si ils ont la même couleur. Pour check la couleur de l'unitig i, il suffit maintenant de regarder dans un bitvector combien de couleurs ont été vues avant i (*Rank*()) et ajouter 1. Le bitvector fonctionne comme tel : 1 si dernier unitig d'une série de même couleur, 0 sinon. (voir figure)
  + Les couleurs sont compréssées via différentes méthodes selon le rapport \|Ci\|/N (Ci : set de references, N : nb references max), notamment Elias' code et/ou bitvector encoding. Tout est ensuite concaténé pour compresser et un *offset* est utilisé pour garder en mémoire les débuts et fin des couleurs
  + Usage de GGCAT pour construire le ccdBG + permet de group by color donc tout est fait en 1 scan de GGCAT

  Différentes stratégies de "pseudoalignement" disponibles (=strat de quels kmers choisir pour déterminer la couleur de la query). Certaines sont exhaustives et vont réaliser ce pseudoalignment pour chaque kmer d'une query, d'autres vont utiliser des heuristiques (type "les prochains kmer vont avoir une chance accrues de partager le même unitig donc skip") /False positives\\. tout est implémenté dans fulgor

#### Résultats

Plus rapide et moins d'espace que Themisto (old SOTA). Perd du temps sur les intersections lors du pseudoalignement


